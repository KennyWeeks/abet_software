from tkinter import *
from encapsulated.testBox import LiveTerminal
from tkinter import Text
from tkinter import filedialog as fd
from tkinter import ttk
import re
import pandas as pd
from toolsObjs.createFolder import CreateFolder
from toolsObjs.exitInt import ExitInt
from toolsObjs.readIndirect import ReadIndirect
from toolsObjs.parseIndirect import ParseIndirect
from toolsObjs.parseDirect import ParseDirect
from dotenv import load_dotenv
import os
import json
from encapsulated.actionMethods import ActionMethods

class BodyFrame(ActionMethods):

	#this needs to be first
	__terminal = None #this is the terminal associated with each tool

	__frame = None #this is the body frame that will hold the terminal, and will be changed with the menu

	#this array is used to determine what frame to load
	__tags = ["Email List", "Create ABET Cabinet", "Audit Direct Assessment", "Parse Direct Assessment", "Parse Exit Interview", "Read Indirect Assessments", "Parse Indirect Assessments", "Settings"]

	__styleFrame = None #this is the frame that holds each tool

	__current = 0 #this is the current frame being shown on the interface

	__toolTitle = None

	__emptyIncorrect = 0 #used in Parse Data section

	__root = None #this is the root application

	__filenames = dict() #this will be when multiple files are selected
	
	__directory = dict() #this will hold multiple directories, and it's ordered by an id

	#these are the variables that are used in the audit to select which subfolder is parsed
	__auditFolders = 1

	#these are check boxes IntVars that are generated by reading csv files
	__checkBoxes = dict()

	#--------------------------------------------------
	#--------------------------------------------------
	#These methods below are attached to specific tags, and will trigger the tool code

	#1) EMAIL LIST
	#this one is specific to the "Email List" tag, this will start the tool
	"""def emailList(self):
		startTool = True #this will be used to determine whether to start the tool or not, it is a unique bool for each frame
		args = "" #these are the arguments pushed to the tool

		if self.__filenames["0"] == "":
			self.__terminal.enterLine("Please provide a class schedule file.")
			startTool = False
		else:
			args += self.__filenames["0"] + ", "

		if self.__filenames["1"] == "":
			self.__terminal.enterLine("Please provide an email list file with professor emails.")
			startTool = False
		else:
			args += self.__filenames["1"]

		#start the tool if possible
		if startTool:
			print(args)
			self.__terminal.enterLine(args)
			#args = self.__filenames["0"] + " " + self.__filenames["1"]
			#self.__terminal.runProcess("tools/emailList.py", args)"""

	#2) CREATE ABET CABINET
	#this tool will trigger the "Create ABET Cabinet" folder
	def createFolder(self, e):
		startTool = True
		args = list()

		#check if the schedule is provided
		if len(self.__filenames.keys()) != 0:
			if self.__filenames["0"] == "":
				self.__terminal.enterLine("Please provide a class schedule file.")
				startTool = False
			else:
				args.append(self.__filenames["0"])
				#We can look at the checkboxes selected here
				allZero = True
				checkB = list()
				for keys in self.__checkBoxes["scheduleFileName"].keys():
					if self.__checkBoxes["scheduleFileName"][keys].get() != 0:
						checkB.append(keys)
						allZero = False
				
				if allZero:
					self.__terminal.enterLine("Please select at least one column to use from the provided file to start the tool")
					startTool = False
				else:
					args.append(checkB)

		else:
			self.__terminal.enterLine("You need to provide a schedule file to start the tool.")
			startTool = False

		#check if the name is provided
		if e.get().strip() == "Enter a folder name here" or e.get().strip() == "":
			self.__terminal.enterLine("Enter a folder name to start using the tool.")
			startTool = False
		else:
			args.append(e.get().strip())

		if len(self.__directory.keys()) != 0:
			if self.__directory["0"] == "":
				self.__terminal.enterLine("Please provide a save directory.")
				startTool = False
			else:
				args.append(self.__directory["0"])
		else:
			self.__terminal.enterLine("You need to provide a save directory to start the tool.")
			startTool = False

		#check if the tool can be started
		if startTool:
			#self.__terminal.enterLine(args)
			inst = CreateFolder(self.__terminal, args)
			inst.createCabinet()
			#self.__terminal.runProcess("tools/createFolder.py", args)

		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")

	def parseDirect(self, e, data):
		startTool = True
		args = list()

		if len(self.__directory.keys()) == 2:
			if self.__directory["0"] == "":
				self.__terminal.enterLine("Please include the directory for the ABET Cabinet")
				startTool = False
			else:
				args.append(self.__directory["0"])

			if self.__directory["1"] == "":
				self.__terminal.enterLine("Please include the save directory for final direct assessment")
				startTool = False
			else:
				args.append(self.__directory["1"])
		else:
			startTool = False
			self.__terminal.enterLine("Please enter both directories to start the tool")

		if e.get().strip() == "Enter a file name here" or e.get().strip() == "":
			self.__terminal.enterLine("Please provide a name for the final direct assessment.")
			startTool = False
		else:
			args.append(e.get().strip())

		fldrsLst = list(data["Subfolders"].keys())
		args.append(fldrsLst[self.__auditFolders-1])
		print(args[-1])

		if startTool:
			self.__terminal.enterLine("Starting the tool ... ")
			pd = ParseDirect(args[0], args[2], args[1], self.__terminal, args[-1])
			gp = pd.returnGp()
			pd.startReading(gp)
			data = pd.returnData()
			pd.makeReport(data)
		else:
			self.__terminal.enterLine("Tool will not start.")

		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")

	#6) EXIT INTERVIEW
	#this tool will trigger the ""
	def exitInterview(self, e):
		startTool = True
		args = list()

		if len(self.__filenames.keys()) != 0:
			if self.__filenames["0"] == "":
				self.__terminal.enterLine("Please include the exit interview data file.")
				startTool = False
			else:
				args.append(self.__filenames["0"])
				#We can look at the checkboxes selected here
				allZero = True
				checkB = list()
				for keys in self.__checkBoxes["exitFileName"].keys():
					if self.__checkBoxes["exitFileName"][keys].get() != 0:
						checkB.append(keys)
						allZero = False
				
				if allZero:
					self.__terminal.enterLine("Please select at least one column to use from the provided file to start the tool")
					startTool = False
				else:
					args.append(checkB)
		else:
			self.__terminal.enterLine("You need to provide an exit interview file to start the tool")
			startTool = False

		#check if a name has been provided
		if e.get().strip() == "Enter a file name here" or e.get().strip() == "":
			self.__terminal.enterLine("Please provide a name for the final parsed data.")
			startTool = False
		else:
			args.append(e.get().strip())

		#Check if the save directory is correct
		if len(self.__directory.keys()) != 0:
			if self.__directory["0"] == "":
				self.__terminal.enterLine("Please provide a save directory.")
				startTool = False
			else:
				args.append(self.__directory["0"])
		else:
			self.__terminal.enterLine("You need to provide a save directory to start the tool.")
			startTool = False

		if startTool:
			inst = ExitInt(self.__terminal, args)
			inst.startParsingData()
			#self.__terminal.enterLine(args)

		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")

	#7) READ INDIRECT
	#this tool will trigger the "Read Indirect" tool
	def readIndirect(self, e):
		startTool = True
		args = list() #these are the arguments pushed to the class that starts the tool

		if len(self.__directory.keys()) == 2:
			if self.__directory["0"] == "":
				self.__terminal.enterLine("Please include the directory with the indirect assessment files")
				startTool = False
			else:
				args.append(self.__directory["0"])

			if self.__directory["1"] == "":
				self.__terminal.enterLine("Please include the save directory for the final data")
				startTool = False
			else:
				args.append(self.__directory["1"])
		else:
			startTool = False
			self.__terminal.enterLine("Please enter both directories to start the tool")

		if e.get().strip() == "Enter a file name here" or e.get().strip() == "":
			self.__terminal.enterLine("Please provide a name for the final data file.")
			startTool = False
		else:
			args.append(e.get().strip())

		if startTool:
			self.__terminal.enterLine("Starting the tool ... ")
			readInd = ReadIndirect(args[0], args[1], args[2], self.__terminal)
			readInd.startTool()
		else:
			self.__terminal.enterLine("Tool will not start.")

		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")


	#8) PARSE INDIRECT
	#this command will trigger the "Parse Indirect" tool
	def parseIndirect(self):
		startTool = True
		args = list()

		if len(self.__filenames.keys()) != 0:
			if self.__filenames["0"] == "":
				self.__terminal.enterLine("Please enter the file that holds the indirect data.")
				startTool = False
			else:
				args.append(self.__filenames["0"])
		else:
			self.__terminal.enterLine("Please enter the file that holds the indirect data.")
			startTool = False

		if len(self.__directory.keys()) != 0:
			if self.__directory["0"] == "":
				self.__terminal.enterLine("Please enter the save directory")
				startTool = False
			else:
				args.append(self.__directory["0"])
		else:
			self.__terminal.enterLine("Please enter the save directory")
			startTool = False

		if startTool:
			self.__terminal.enterLine("Starting the tool ... ")
			parseInd = ParseIndirect(args[0], args[1], self.__terminal)
			parseInd.startReading()
			parseInd.createResult()
		else:
			self.__terminal.enterLine("Tool will not Start.")

		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")
	#--------------------------------------------------
	#--------------------------------------------------

	#--------------------------------------------------
	#--------------------------------------------------
	#These methods will be used to store data that will be pushed to the tools, and will generally be attached to button calls

	#this will save multiple files, and it will also position to the label
	def getFile(self, name, i, frame, bf, cv):
		"""
		-Parameter Desc
		-self --> the class instance
		-name --> name of label to list final file
		-i --> key used to save the file to __filenames dictionary
		-frame --> where the headers are placed if the file is an .xlsx or .csv
		-bf --> bodyframe of the available data
		-cv --> canvas that displays application
		"""

		filename = fd.askopenfilename() #ask the user for the file
		if len(filename) == 0:
			self.deleteChildren(True, bf, name, frame, cv)
			self.__checkBoxes[name] = dict() #reset the dictionary
			self.__filenames[i] = "" #even if nothing is provided, I want the dictionary to start getting filed
		else:
			#this is if there is no file selected, add the label so the user can see there file selected
			pos = [m.start() for m in re.finditer("/", filename)]
			file = filename[pos[-1]+1:]
			for c in bf.winfo_children():
				if str(type(c)) == "<class 'tkinter.Label'>":
					if str(c).find(name) != -1:
						c.config(text="+-----------> " + file)
			self.__root.focus_set()
			self.__filenames[str(i)] = filename #save the file name
			
			#if I need to list headers, i will, otherwise, no frame is provided
			if frame != None:
				self.getHeaderOfFiles(filename, frame, bf, cv, name)

	def getHeaderOfFiles(self, file, frame, bf, cv, name):
		#remove the label from the frame
		self.deleteChildren(False, bf, name, frame, cv)

		#add the checkboxes to the newly cleared frame
		pandasData = pd.read_excel(file)
		r=0
		self.__checkBoxes[name] = dict()
		for col in pandasData.columns:
			#lbl = Label(frame, text=col)
			self.__checkBoxes[name][col] = IntVar()
			chkBt = Checkbutton(frame, text=col, variable=self.__checkBoxes[name][col], onvalue=1, offvalue=0, wraplength=300, justify=LEFT)
			chkBt.grid(sticky=W, row=r, column=0)
			r+=1

		#This will update the canvas size
		cv.update_idletasks()
		cv.configure(scrollregion=bf.bbox("all"))

	#This will scan entry clicks to text boxes
	def entryClick(self, event, entryBox):
		#okay, this is kinda stupid, but that's because tkinter is pretty limited,
		#there is a default text that I want to get rid of when the user clicks on the entry box
		if entryBox.get().strip() == "Enter a folder name here" or entryBox.get().strip() == "Enter a file name here":
			entryBox.delete(0, len(entryBox.get()))
			entryBox.config(fg="#000000")

	def getFolderForGrid(self, bf, name, i):
		directory = fd.askdirectory()
		if len(directory) == 0:
			for c in bf.winfo_children():
				if str(type(c)) == "<class 'tkinter.Label'>":
					if str(c).find(name) != -1:
						c.config(text="+-----------> No Directory Selected")
			self.__directory[i] = ""
		else:
			pos = [m.start() for m in re.finditer("/", directory)]
			direct = directory[pos[-1]+1:]
			for c in bf.winfo_children():
				if str(type(c)) == "<class 'tkinter.Label'>":
					if str(c).find(name) != -1:
						c.config(text="+-----------> " + direct)
			self.__root.focus_set()
			self.__directory[i] = directory #append the directory as needed

	def deleteChildren(self, empty, parent, name, frame, cv):
		"""
		Parameter description
		parent --> this is the body object that needs to have things deleted from it
		name --> this is the name of the specific child that will have it's contents deleted
		frame --> this will mostly be used for deleting headers and the checkboxes associated with them generated by the app
		cv --> this is associated with the frame, if provided, we need to resize the canvas
		"""
		for c in parent.winfo_children():
			if str(type(c)) == "<class 'tkinter.Label'>":
				if str(c).find(name) != -1 and empty:
					c.config(text="+-----------> No File Selected") #clear this specific label

				#remove frame children
				if frame != None:
					for frC in frame.winfo_children():
						frC.grid_forget()

						cv.update_idletasks()
						cv.configure(scrollregion=parent.bbox("all"))

					frame.config(height=0) #set everything back to 0
					cv.update_idletasks()
					cv.configure(scrollregion=parent.bbox("all"))

					if empty:
						noCheckBox = Label(frame, text="+-----------> No Headers Available", bg="#323232", fg="#ffffff")
						noCheckBox.grid(sticky=W, row=0, column=0)

						cv.update_idletasks()
						cv.configure(scrollregion=parent.bbox("all"))

	def checkRadio(self, selected):
		self.__auditFolders = selected;

	#--------------------------------------------------
	#--------------------------------------------------

	#--------------------------------------------------
	#--------------------------------------------------
	#Alright, cause I don't want to code each frame into one function, I'm make them different functions, and then
	#store them in an array, and see what happens. 

	#1) EMAIL LIST
	def EmailList(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal for Parsing Email List-->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")

		"""------------------------
		This section is kinda a hack, it will allow the user to scroll through the application
		because tkinter doesn't have a dedicated scrolling options, and I would like to keep the 
		design as compact as possible
		------------------------"""

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		#this will prompt the user to select the file that lists the available classes
		selectFileDesc = Text(bodyFrame, bg="#323232", width=40, height=3, wrap=WORD, highlightthickness=0)
		selectFileDesc.insert('1.0', "--> Select the schedule file (.xlsx or .csv) that lists the current semesters schedule.")
		selectFileDesc.config(state=DISABLED)
		selectFileDesc.grid(sticky=W, row=2, column=0, padx=10, pady=5)

		#--------------------------
		#this is for selecting a file

		#this is for later, this just needs to be defined here
		scheduleFrame = Frame(bodyFrame, width=330, name="scFm")

		#this will prompt the user to select a file to use for this part of the tool
		selectFileButton = Button(bodyFrame, text="Select Schedule File", command=lambda x=165, y=65: self.getFile("scheduleFileName", "0", scheduleFrame, bodyFrame, canvas))
		selectFileButton.grid(sticky=W, row=3, column=0, padx=5)

		selectedFileName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="scheduleFileName")
		selectedFileName.grid(sticky=W, row=4, column=0, padx=7)

		#this is wherre the headers of the file will be displayed
		selectedFileHeaderDesc = Text(bodyFrame, bg="#323232", width=40, height=5, wrap=WORD, highlightthickness=0)
		selectedFileHeaderDesc.insert('1.0', "--> The header columns of the selected file will be displayed. Select the ones to be used by the tool. Please select the columns in this order: [Professor's Name, Class Number, Class Section]")
		selectedFileHeaderDesc.config(state=DISABLED)
		selectedFileHeaderDesc.grid(sticky=W, row=5, column=0, padx=10, pady=5)

		scheduleFrame.grid(sticky=W, row=6, column=0, padx=10)
		#----------------------------
		#this will select the destination of the associated email file


		destinationOfResutlingFile = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		destinationOfResutlingFile.insert('1.0', "--> Select the destination of final email file created by the tool.")
		destinationOfResutlingFile.config(state=DISABLED)
		destinationOfResutlingFile.grid(sticky=W, row=12, column=0, padx=10, pady=5)

		destinationButton = Button(bodyFrame, text="Select Save Directory", command=lambda:self.getFolderForGrid(bodyFrame, "saveDirectory", "0"))
		destinationButton.grid(sticky=W, row=13, column=0, padx=5)

		destinationLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="saveDirectory")
		destinationLabel.grid(sticky=W, row=14, padx=7)
		#----------------------------

		startTool = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startTool.insert('1.0', "--> Press the button below to start the tool.")
		startTool.config(state=DISABLED)
		startTool.grid(sticky=W, row=15, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=lambda f=self.__filenames, c=self.__checkBoxes, d=self.__directory: self.emailList(f, c, d))
		startToolButton.grid(sticky=W, row=16, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=17, column=0, padx=5)

	#2) CREATE ABET CABINET
	def CabinetCreate(self):
		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine(" Progess terminal for Cabinet Creation ")
		self.__terminal.enterLine("+++++++++++++++++++++++++++++++++++++++++++++++")

		"""------------------------
		This section is kinda a hack, it will allow the user to scroll through the application
		because tkinter doesn't have a dedicated scrolling options, and I would like to keep the 
		design as compact as possible
		------------------------"""

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFileDesc = Text(bodyFrame, bg="#323232", width=40, height=4, wrap=WORD, highlightthickness=0)
		selectFileDesc.insert('1.0', "--> The 'Select File' button will open a file dialog so the user can select either the .xlsx or .csv file that shows the available classes offered.")
		selectFileDesc.config(state=DISABLED)
		selectFileDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this is for later, this just needs to be defined here
		scheduleFrame = Frame(bodyFrame, width=330, name="scFm")

		#this will prompt the user to select a file to use for this part of the tool
		selectFileButton = Button(bodyFrame, text="Select Schedule File", command=lambda x=165, y=65: self.getFile("scheduleFileName", "0", scheduleFrame, bodyFrame, canvas))
		selectFileButton.grid(sticky=W, row=3, column=0, padx=5)

		selectedFileName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="scheduleFileName")
		selectedFileName.grid(sticky=W, row=4, column=0, padx=7)

		#this is wherre the headers of the file will be displayed
		selectedFileHeaderDesc = Text(bodyFrame, bg="#323232", width=40, height=3, wrap=WORD, highlightthickness=0)
		selectedFileHeaderDesc.insert('1.0', "--> The header columns of the selected file will be displayed. Select the ones to be used by the tool.")
		selectedFileHeaderDesc.config(state=DISABLED)
		selectedFileHeaderDesc.grid(sticky=W, row=5, column=0, padx=10, pady=5)

		scheduleFrame.grid(sticky=W, row=6, column=0, padx=5)

		#add label to the frame
		noCheckBox = Label(scheduleFrame, text="+-----------> No Headers Available", bg="#323232", fg="#ffffff")
		noCheckBox.grid(sticky=W, row=0, column=0)

		#this is the entry area
		entryDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		entryDesc.insert('1.0', "--> Enter the name of the folder that will be used for the cabinet")
		entryDesc.config(state=DISABLED)
		entryDesc.grid(sticky=W, row=7, column=0, padx=10, pady=5)

		entryBox = Entry(bodyFrame, bg="#ffffff", fg="#bebebe", highlightthickness=0)
		entryBox.insert(0, "Enter a folder name here")
		entryBox.grid(sticky=W, row=8, column=0, padx=10, pady=10)
		entryBox.config(insertbackground="#000000")

		entryBox.bind("<Button-1>", lambda event, e=entryBox: self.entryClick(event, e))

		#----------------------------
		#this will select the destination of the associated email file

		destinationOfResutlingFile = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		destinationOfResutlingFile.insert('1.0', "--> Select the destination of final cabinet.")
		destinationOfResutlingFile.config(state=DISABLED)
		destinationOfResutlingFile.grid(sticky=W, row=9, column=0, padx=10, pady=5)

		destinationButton = Button(bodyFrame, text="Select Save Directory", command=lambda:self.getFolderForGrid(bodyFrame, "saveDirectory", "0"))
		destinationButton.grid(sticky=W, row=10, column=0, padx=5)

		destinationLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="saveDirectory")
		destinationLabel.grid(sticky=W, row=11, padx=7)
		#----------------------------

		#Start the tool now
		startToolDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startToolDesc.insert('1.0', "--> Start the tool by pressing the button below.")
		startToolDesc.config(state=DISABLED)
		startToolDesc.grid(sticky=W, row=12, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=lambda :self.createFolder(entryBox))
		startToolButton.grid(sticky=W, row=13, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=14, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

	#6) EXIT INTERVIEW
	def ExitInterview(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal for Parsing Exit Int. -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFileDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFileDesc.insert('1.0', "--> Select the file that holds the exit interview results.")
		selectFileDesc.config(state=DISABLED)
		selectFileDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this is for later, this just needs to be defined here
		exitFrame = Frame(bodyFrame, width=330, name="exFm")

		#this will prompt the user to select a file to use for this part of the tool
		selectFileButton = Button(bodyFrame, text="Select Exit Interview Results", command=lambda x=165, y=65: self.getFile("exitFileName", "0", exitFrame, bodyFrame, canvas))
		selectFileButton.grid(sticky=W, row=3, column=0, padx=5)

		selectedFileName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="exitFileName")
		selectedFileName.grid(sticky=W, row=4, column=0, padx=7)

		#this is wherre the headers of the file will be displayed
		selectedFileHeaderDesc = Text(bodyFrame, bg="#323232", width=40, height=3, wrap=WORD, highlightthickness=0)
		selectedFileHeaderDesc.insert('1.0', "--> The header columns of the selected file will be displayed. Select the columns to be used by the tool.")
		selectedFileHeaderDesc.config(state=DISABLED)
		selectedFileHeaderDesc.grid(sticky=W, row=5, column=0, padx=10, pady=5)

		exitFrame.grid(sticky=W, row=6, column=0, padx=5)

		#add label to the frame
		noCheckBox = Label(exitFrame, text="+-----------> No Headers Available", bg="#323232", fg="#ffffff")
		noCheckBox.grid(sticky=W, row=0, column=0)

		#this is the entry area
		entryDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		entryDesc.insert('1.0', "--> Enter the name of the file for the parsed exit interview data.")
		entryDesc.config(state=DISABLED)
		entryDesc.grid(sticky=W, row=7, column=0, padx=10, pady=5)

		entryBox = Entry(bodyFrame, bg="#ffffff", fg="#bebebe", highlightthickness=0)
		entryBox.insert(0, "Enter a file name here")
		entryBox.grid(sticky=W, row=8, column=0, padx=10, pady=10)
		entryBox.config(insertbackground="#000000")

		entryBox.bind("<Button-1>", lambda event, e=entryBox: self.entryClick(event, e))

		#----------------------------
		#this will select the destination of the associated email file

		destinationOfResutlingFile = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		destinationOfResutlingFile.insert('1.0', "--> Select the destination of the final parsed exit interview here.")
		destinationOfResutlingFile.config(state=DISABLED)
		destinationOfResutlingFile.grid(sticky=W, row=9, column=0, padx=10, pady=5)

		destinationButton = Button(bodyFrame, text="Select Save Directory", command=lambda:self.getFolderForGrid(bodyFrame, "saveDirectory", "0"))
		destinationButton.grid(sticky=W, row=10, column=0, padx=5)

		destinationLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="saveDirectory")
		destinationLabel.grid(sticky=W, row=11, padx=7)
		#----------------------------

		#Start the tool now
		startToolDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startToolDesc.insert('1.0', "--> Start the tool by pressing the button below.")
		startToolDesc.config(state=DISABLED)
		startToolDesc.grid(sticky=W, row=12, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=lambda :self.exitInterview(entryBox))
		startToolButton.grid(sticky=W, row=13, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=14, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		"""selectFolderDesc = Text(self.__styleFrame, bg="#323232", width=40, height=10, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the exit interview results file.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.place(x=10, y=10)

		selectFile = Button(self.__styleFrame, text="Select Exit Data", command=lambda x=145, y=37: self.getFile(x, y, "exitData", "0"))
		selectFile.place(x=5, y=35)

		nameFinalFileDesc = Text(self.__styleFrame, bg="#323232", width=40, height=5, wrap=WORD, highlightthickness=0)
		nameFinalFileDesc.insert("1.0", "--> Name the file that will hold the parsed exit interview. (*.csv)")
		nameFinalFileDesc.config(state=DISABLED)
		nameFinalFileDesc.place(x=10, y=65)

		#This is the entry box
		entryBox = Entry(self.__styleFrame, bg="#ffffff", fg="#bebebe", highlightthickness=0)
		entryBox.insert(0, "Enter a folder name here")
		entryBox.place(x=8, y=96, width=200)
		entryBox.config(insertbackground="#000000")

		entryBox.bind("<Button-1>", lambda event, e=entryBox: self.entryClick(event, e))

		startToolDesc = Text(self.__styleFrame, bg="#323232", width=40, height=1, wrap=WORD, highlightthickness=0)
		startToolDesc.insert("1.0", "--> Start Tool")
		startToolDesc.config(state=DISABLED)
		startToolDesc.place(x=10, y=125)

		startTool = Button(self.__styleFrame, text="Start Tool", command=lambda e=entryBox: self.exitInterview(e))
		startTool.place(x=5, y=138)"""

	#6) READ INDIRECT
	def ReadIndirect(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal to Read Indirect Reports -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the directory where the indirect assessment is stored.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		indirectFolderButton = Button(bodyFrame, text="Select Directory with Indirect Files", command=lambda:self.getFolderForGrid(bodyFrame, "indirectFolder", "0"))
		indirectFolderButton.grid(sticky=W, row=10, column=0, padx=5)

		indirectFolderLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="indirectFolder")
		indirectFolderLabel.grid(sticky=W, row=11, padx=7)

		#----------------------------
		#this will select the destination of the associated parsed file

		destinationOfResutlingFile = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		destinationOfResutlingFile.insert('1.0', "--> Select the destination of the final parsed data from the indirect assessment here.")
		destinationOfResutlingFile.config(state=DISABLED)
		destinationOfResutlingFile.grid(sticky=W, row=12, column=0, padx=10, pady=5)

		destinationButton = Button(bodyFrame, text="Select Save Directory", command=lambda:self.getFolderForGrid(bodyFrame, "saveDirectory", "1"))
		destinationButton.grid(sticky=W, row=13, column=0, padx=5)

		destinationLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="saveDirectory")
		destinationLabel.grid(sticky=W, row=14, padx=7)

		#---------------------------
		#this is the entry area
		entryDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		entryDesc.insert('1.0', "--> Enter the name of the file for that holds the parsed data. (*.csv)")
		entryDesc.config(state=DISABLED)
		entryDesc.grid(sticky=W, row=15, column=0, padx=10, pady=5)

		entryBox = Entry(bodyFrame, bg="#ffffff", fg="#bebebe", highlightthickness=0)
		entryBox.insert(0, "Enter a file name here")
		entryBox.grid(sticky=W, row=16, column=0, padx=10, pady=7)
		entryBox.config(insertbackground="#000000")

		entryBox.bind("<Button-1>", lambda event, e=entryBox: self.entryClick(event, e))

		#----------------------------

		#Start the tool now
		startToolDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startToolDesc.insert('1.0', "--> Start the tool by pressing the button below.")
		startToolDesc.config(state=DISABLED)
		startToolDesc.grid(sticky=W, row=17, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=lambda: self.readIndirect(entryBox))
		startToolButton.grid(sticky=W, row=18, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=19, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

	#8) PARSE INDIRECT
	def ParseIndirect(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal for Parsing Indirect Data -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFileDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFileDesc.insert('1.0', "--> Select the file that holds the indirect assessment data.")
		selectFileDesc.config(state=DISABLED)
		selectFileDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		selectFileButton = Button(bodyFrame, text="Select Indirect Results File", command=lambda x=165, y=65: self.getFile("indirectAssessment", "0", None, bodyFrame, canvas))
		selectFileButton.grid(sticky=W, row=2, column=0, padx=5)

		selectedFileName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="indirectAssessment")
		selectedFileName.grid(sticky=W, row=3, column=0, padx=7)


		#----------------------
		#this is the save destination

		destinationOfResutlingFile = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		destinationOfResutlingFile.insert('1.0', "--> Select the destination of the further parsed data.")
		destinationOfResutlingFile.config(state=DISABLED)
		destinationOfResutlingFile.grid(sticky=W, row=12, column=0, padx=10, pady=5)

		destinationButton = Button(bodyFrame, text="Select Save Directory", command=lambda:self.getFolderForGrid(bodyFrame, "saveDirectory", "0"))
		destinationButton.grid(sticky=W, row=13, column=0, padx=5)

		destinationLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="saveDirectory")
		destinationLabel.grid(sticky=W, row=14, padx=7)

		#-----------------------
		#this will start the tool

		#Start the tool now
		startToolDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startToolDesc.insert('1.0', "--> Start the tool by pressing the button below.")
		startToolDesc.config(state=DISABLED)
		startToolDesc.grid(sticky=W, row=17, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=self.parseIndirect)
		startToolButton.grid(sticky=W, row=18, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=19, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))


	#4) AUDIT FOLDER
	#this tool will trigger the "Audit folder" tool
	def auditFolder(self, e, ce, se, ea):
		self.__terminal.enterLine("---------------------")
		startTool = True #this is a flag to start the tool
		args = "" #this is the arguments that are passed to the tool

		#this will check to see if the two directories have been chosen
		if self.__directory["0"] == "":
			self.__terminal.enterLine("Missing the path to the directory with the assessment.")
		else:
			args += self.__directory["0"] + " "

		if self.__directory["1"] == "":
			self.__terminal.enterLine("Missing the path to the directory for the final saved audit.")
		else:
			args += self.__directory["1"] + " "

		#This will get the text written in the entry block
		if e.get().strip() == "Enter a folder name here" or e.get().strip() == "":
			self.__terminal.enterLine("Please enter the name of the final save file.")
			startTool = False
		else:
			args += e.get().strip() + " "

		#parse through which check marks have been made
		if ce.get() == 1:
			args += "True "
		else:
			args += "False "

		if se.get() == 1:
			args += "True "
		else:
			args += "False "

		if ea.get() == 1:
			args += "True "
		else:
			args += "False " 

		#Parse through which folder to check
		if self.__auditFolders == 1:
			args += "All"
		elif self.__auditFolders == 2:
			args += "Syllabus"
		elif self.__auditFolders == 3:
			args += "Handouts"
		elif self.__auditFolders == 4:
			args += "Assignments"
		elif self.__auditFolders == 5:
			args += "Exams"
		elif self.__auditFolders == 6:
			args += "Outcome"

		#This will start the tool
		if startTool:
			print(args)
			self.__terminal.enterLine("Starting tool")
			self.__terminal.runProcess("tools/audit.py", args)
		else:
			print("Nope, there are issues")

	#4) AUDIT FOLDER
	def AuditCabinet(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal for the Audit -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++")

		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		bodyFrame = Frame(canvas)

		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		r=1
		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the file that holds the exit interview results.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		selectFolderButton = Button(bodyFrame, text="Select ABET Folder to Audit", command=lambda x=165, y=65: self.getFolderForGrid(bodyFrame, "auditCabinet", "0"))
		selectFolderButton.grid(sticky=W, row=2, column=0, padx=5)

		selectedFolderName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="auditCabinet")
		selectedFolderName.grid(sticky=W, row=3, column=0, padx=7)

		"""beginAuditDesc = Label(bodyFrame, text="--> Once you've downloaded the current ABET Folder, you can perform an audit to see if the folder is up to date.", bg="#323232", fg="#ffffff", wraplength=300, justify=LEFT)
		beginAuditDesc.grid(sticky=W, row=3, column=0, padx=5, pady=5)"""

		selectParamsForAudit = Label(bodyFrame, text="--> Before you start the audit, you can select which subfolder the program will audit, as well as how much of each subfolder is filled.", bg="#323232", fg="#ffffff", wraplength=300, justify=LEFT)
		selectParamsForAudit.grid(sticky=W, row=4, column=0, padx=5, pady=5)

		divider = Label(bodyFrame, text="------------------------------------", bg="#323232", fg="#ffffff", wraplength=300, justify=LEFT)
		divider.grid(sticky=W, row=5, column=0, padx=5)

		titleRadio = Label(bodyFrame, text="-- Select which subfolder to audit --", bg="#323232", fg="#ffffff", justify=LEFT)
		titleRadio.grid(sticky=W, row=6, column=0, padx=5)

		#---------------
		#Subfolder check
		allCheckBox = Radiobutton(bodyFrame, text="Audit all subfolders", variable=self.__auditFolders, value=1, command=lambda :self.checkRadio(1))
		allCheckBox.select()
		allCheckBox.grid(sticky=W, row=7, column=0, padx=5, pady=5)

		sylCheckBox = Radiobutton(bodyFrame, text="Audit only Syllabus ", variable=self.__auditFolders, value=2, command=lambda: self.checkRadio(2))
		sylCheckBox.grid(sticky=W, row=8, column=0, padx=5, pady=5)

		handCheckBox = Radiobutton(bodyFrame, text="Audit only Handouts", variable=self.__auditFolders, value=3, command=lambda: self.checkRadio(3))
		handCheckBox.grid(sticky=W, row=9, column=0, padx=5, pady=5)

		assCheckBox = Radiobutton(bodyFrame, text="Audit only Assignments", variable=self.__auditFolders, value=4, command=lambda: self.checkRadio(4))
		assCheckBox.grid(sticky=W, row=10, column=0, padx=5, pady=5)

		examsCheckBox = Radiobutton(bodyFrame, text="Audit only Exams", variable=self.__auditFolders, value=5, command=lambda: self.checkRadio(5))
		examsCheckBox.grid(sticky=W, row=11, column=0, padx=5, pady=5)

		outCheckBox = Radiobutton(bodyFrame, text="Audit only Outcome", variable=self.__auditFolders, value=6, command=lambda: self.checkRadio(6))
		outCheckBox.grid(sticky=W, row=12, column=0, padx=5, pady=5)

		divider = Label(bodyFrame, text="------------------------------------", bg="#323232", fg="#ffffff", wraplength=300, justify=LEFT)
		divider.grid(sticky=W, row=13, column=0, padx=5)

		titleCheck = Label(bodyFrame, text="-- Select how the audit works --", bg="#323232", fg="#ffffff", justify=LEFT)
		titleCheck.grid(sticky=W, row=14, column=0, padx=5)

		countEmptyV = IntVar()
		showEmptyV = IntVar()
		emailAuditV = IntVar()

		countEmpty = Checkbutton(bodyFrame, text="Count empty folders", variable=countEmptyV, onvalue=1, offvalue=0)
		countEmpty.grid(sticky=W, row=15, column=0, pady=5, padx=5)

		showFinalEmpty = Checkbutton(bodyFrame, text="Show empty subfolders in final audit", variable=showEmptyV, onvalue=1, offvalue=0)
		showFinalEmpty.grid(sticky=W, row=16, column=0, pady=5, padx=5)

		emailAudit = Checkbutton(bodyFrame, text="Email Audit", variable=emailAuditV, onvalue=1, offvalue=0)
		emailAudit.grid(sticky=W, row=17, column=0, pady=5, padx=5)

		divider = Label(bodyFrame, text="------------------------------------", bg="#323232", fg="#ffffff", wraplength=300, justify=LEFT)
		divider.grid(sticky=W, row=18, column=0, padx=5)

		nameAudit = Label(bodyFrame, text="--> Name the final audit file (*.txt)", bg="#323232", fg="#ffffff", justify=LEFT)
		nameAudit.grid(sticky=W, row=19, column=0, padx=5, pady=5)

		entryBox = Entry(bodyFrame, bg="#ffffff", fg="#000000", highlightthickness=0)
		#entryBox.insert(0, "Enter a folder name here")
		entryBox.grid(sticky=W, row=20, column=0, padx=9, pady=5)
		entryBox.config(insertbackground="#000000")

		selectSaveDir = Label(bodyFrame, text="--> Select the directory to save the audit", bg="#323232", fg="#ffffff")
		selectSaveDir.grid(sticky=W, row=21, column=0, padx=5, pady=5)

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the directory to save the audit.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=22, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		selectFolderButton = Button(bodyFrame, text="Select Save Directory", command=lambda x=165, y=65: self.getFolderForGrid(bodyFrame, "saveDir", "1"))
		selectFolderButton.grid(sticky=W, row=23, column=0, padx=5)

		selectedFolderName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="saveDir")
		selectedFolderName.grid(sticky=W, row=24, column=0, padx=7)

		startAudit = Label(bodyFrame, text="--> Start the audit", bg="#323232", fg="#ffffff")
		startAudit.grid(sticky=W, row=25, column=0, padx=5, pady=5)

		strAuditB = Button(bodyFrame, text="Start Audit", command=lambda e=entryBox, ce=countEmptyV, se=showEmptyV, ea=emailAuditV: self.auditFolder(e, ce, se, ea))
		strAuditB.grid(sticky=W, row=26, column=0, padx=5)

		lbl = Label(bodyFrame)
		lbl.grid(sticky=W, row=27, column=0, pady=5)

	def ParseDirect(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Progess terminal for the Audit -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++")

		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		canvas.configure(yscrollcommand=scrollBar.set)
		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		bodyFrame = Frame(canvas)

		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		r=1
		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the most recent ABET Cabinet directory.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		indirectFolderButton = Button(bodyFrame, text="Select ABET Cabinet Directory", command=lambda:self.getFolderForGrid(bodyFrame, "directCabinet", "0"))
		indirectFolderButton.grid(sticky=W, row=2, column=0, padx=5)

		indirectFolderLabel = Label(bodyFrame, text="+-----------> No Directory Selected", fg="#ffffff", bg="#323232", name="directCabinet")
		indirectFolderLabel.grid(sticky=W, row=3, padx=7)

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the directory to save the direct assessment data.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=4, column=0, padx=10, pady=5)

		#this will prompt the user to select a file to use for this part of the tool
		selectFolderButton = Button(bodyFrame, text="Select Save Directory", command=lambda x=165, y=65: self.getFolderForGrid(bodyFrame, "saveDir", "1"))
		selectFolderButton.grid(sticky=W, row=5, column=0, padx=5)

		selectedFolderName = Label(bodyFrame, text="+-----------> No File Selected", fg="#ffffff", bg="#323232", name="saveDir")
		selectedFolderName.grid(sticky=W, row=6, column=0, padx=7)

		#---------------------------
		#this is where the user will select with folder to search for the outcome

		selectFolderDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		selectFolderDesc.insert('1.0', "--> Select the directory that holds the ABET outcome data.")
		selectFolderDesc.config(state=DISABLED)
		selectFolderDesc.grid(sticky=W, row=7, column=0, padx=10, pady=5)

		outputFolderToSearch = Frame(bodyFrame, bg="#323232", width=330, height=50)
		outputFolderToSearch.grid(sticky=W, row=8, column=0)

		data = open("encapsulated/settings.json", "r")
		jsonData = json.load(data)

		self.__auditFolders = list(jsonData["Subfolders"].keys()).index("Outcome") + 1

		val = 1 #this is the radio button value
		for keys in jsonData["Subfolders"].keys():
			radio = Radiobutton(outputFolderToSearch, text=keys, variable=self.__auditFolders, value=val, command=lambda v=val: self.checkRadio(v))
			if keys == "Outcome":
				radio.select()
				
			radio.grid(sticky=W, row=val, column=0, padx=5, pady=5)
			val += 1

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		"""sylCheckBox = Radiobutton(bodyFrame, text="Audit only Syllabus ", variable=self.__auditFolders, value=2, command=lambda: self.checkRadio(2))
		sylCheckBox.grid(sticky=W, row=8, column=0, padx=5, pady=5)

		handCheckBox = Radiobutton(bodyFrame, text="Audit only Handouts", variable=self.__auditFolders, value=3, command=lambda: self.checkRadio(3))
		handCheckBox.grid(sticky=W, row=9, column=0, padx=5, pady=5)

		assCheckBox = Radiobutton(bodyFrame, text="Audit only Assignments", variable=self.__auditFolders, value=4, command=lambda: self.checkRadio(4))
		assCheckBox.grid(sticky=W, row=10, column=0, padx=5, pady=5)

		examsCheckBox = Radiobutton(bodyFrame, text="Audit only Exams", variable=self.__auditFolders, value=5, command=lambda: self.checkRadio(5))
		examsCheckBox.grid(sticky=W, row=11, column=0, padx=5, pady=5)

		outCheckBox = Radiobutton(bodyFrame, text="Audit only Outcome", variable=self.__auditFolders, value=6, command=lambda: self.checkRadio(6))
		outCheckBox.grid(sticky=W, row=12, column=0, padx=5, pady=5)"""

		#---------------------------

		#---------------------------
		#this is the entry area
		entryDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		entryDesc.insert('1.0', "--> Enter the name of the file for that holds the parsed data. (*.csv)")
		entryDesc.config(state=DISABLED)
		entryDesc.grid(sticky=W, row=9, column=0, padx=10, pady=5)

		entryBox = Entry(bodyFrame, bg="#ffffff", fg="#bebebe", highlightthickness=0)
		entryBox.insert(0, "Enter a file name here")
		entryBox.grid(sticky=W, row=10, column=0, padx=10, pady=7)
		entryBox.config(insertbackground="#000000")

		entryBox.bind("<Button-1>", lambda event, e=entryBox: self.entryClick(event, e))

		#-----------------------
		#this will start the tool

		#Start the tool now
		startToolDesc = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		startToolDesc.insert('1.0', "--> Start the tool by pressing the button below.")
		startToolDesc.config(state=DISABLED)
		startToolDesc.grid(sticky=W, row=11, column=0, padx=10, pady=5)

		startToolButton = Button(bodyFrame, text="Start Tool", command=lambda data=jsonData: self.parseDirect(entryBox, data))
		startToolButton.grid(sticky=W, row=12, column=0, padx=5)

		divider2 = Label(bodyFrame, font=("san-serif", 3))
		divider2.grid(sticky=W, row=13, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

	def Settings(self):
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")
		self.__terminal.enterLine("- Settings Progress Terminal -->")
		self.__terminal.enterLine("++++++++++++++++++++++++++++++++++++++++++++++++")

		#this will open the settings file so it can be used.
		file = open("encapsulated/settings.json", "r+")
		settingsValues = json.load(file)

		#this canvas will hold the scrollbar, as well as the frame that will grow with the scrollbar
		canvas = Canvas(self.__styleFrame, highlightthickness=0)
		canvas.pack(side=LEFT, fill=BOTH, expand=1)

		#this is the scrollbar associated with the canvas
		scrollBar = ttk.Scrollbar(self.__styleFrame, orient=VERTICAL, command=canvas.yview)
		scrollBar.pack(side=RIGHT, fill=Y)

		#scrollBarH = Scrollbar(canvas, orient="horizontal", command=canvas.xview)
		#scrollBarH.pack(side=BOTTOM, fill=X)

		#this sets the scrollbar to work with the canvas
		canvas.configure(yscrollcommand=scrollBar.set)
		#canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		canvas.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))

		#this is the bodyframe that will hold content of the application
		bodyFrame = Frame(canvas)

		#this is like creating a window inside the canvas, that will grow, almost drawing the 
		#tool as it expands
		canvas.create_window((0, 0), window=bodyFrame, anchor="nw")

		"""------------------------
		This is the actual content of the application, it is the part of the interface that will prompt
		the user for action
		------------------------"""

		#this will introduce what is going on with this section
		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=0, column=0, padx=5)

		#this is the intro text block telling the user what they can do with this section
		introLabel = Text(bodyFrame, bg="#323232", width=40, height=4, wrap=WORD, highlightthickness=0)
		introLabel.insert('1.0', "--> This section will allow you to define what classes, subfolders, and outcomes the tool will generate and use to parse the data correctly.")
		introLabel.config(state=DISABLED)
		introLabel.grid(sticky=W, row=1, column=0, padx=10, pady=5)

		dividingLabel = Text(bodyFrame, bg="#323232", width=40, height=1, wrap=WORD, highlightthickness=0)
		dividingLabel.insert('1.0', "----------------------------------------")
		dividingLabel.config(state=DISABLED)
		dividingLabel.grid(sticky=W, row=2, column=0, padx=10)

		#this is a frame that will hold the class names, their outcomes, and an operation button
		classFrame = Frame(bodyFrame, bg="#323232", width=330, height=50)
		classFrame.grid(sticky=W, row=3, column=0)

		#--------
		#These are the columns for this section, add to the classFrame, NOT bodyFrame
		#--------
		classLabel = Label(classFrame, bg="#323232", fg="#ffffff", text="Class Name")
		classLabel.grid(sticky=W, row=1, column=1, padx=10, pady=5)

		outcomeLabel = Label(classFrame, bg="#323232", fg="#ffffff", text="Class Outcomes")
		outcomeLabel.grid(sticky=W, row=1, column=2, padx=10, pady=5)

		opLabel = Label(classFrame, bg="#323232", fg="#ffffff", text="Operation")
		opLabel.grid(sticky=W, row=1, column=3, pady=5)

		#Adding Labels here

		row = 2 #starting row
		for keys in settingsValues["Classes"].keys():

			#this is dynamic based on the values in the settings.json file
			classesLabel = Label(classFrame, bg="#323232", fg="#ffffff", text="+ " + keys + " -->", name="label"+keys)
			classesLabel.grid(sticky=W, row=row, column=1, padx=10, pady=5)

			#this will format the different outcomes needed
			if len(settingsValues["Classes"][keys]) > 1:
				outcomes = "" #this string will hold the outcomes
				#if there is more then one outcome, do it here
				for out in settingsValues["Classes"][keys]:
					if len(settingsValues["Classes"][keys]) - 1 != settingsValues["Classes"][keys].index(out):
						outcomes += str(out) + ", "
					else:
						outcomes += str(out)
			else:
				#if there is only one outcome, do this
				outcomes = settingsValues["Classes"][keys][0]

			#create the label that holds the outcomes
			classesOutcome = Label(classFrame, bg="#323232", fg="#ffffff", text=outcomes, name="out"+keys)
			classesOutcome.grid(sticky=W, row=row, column=2, padx=10, pady=5)

			#create the button that will complete the different operations
			deleteButton = Button(classFrame, text="del", name="but"+keys, command=lambda name=keys: self.removeFromEnv( name, classFrame, canvas, bodyFrame, "Classes"))
			deleteButton.grid(sticky=W, row=row, column=3, pady=5)

			row+=1

		#update the canvas
		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		#------
		#these are dividing labels that will separate the addition section from the rest of the rows
		dividingLabel = Label(classFrame, text="----------", bg="#323232", fg="#ffffff")
		dividingLabel.grid(sticky=W, row=row, column=1, padx=10)

		dividingLabel = Label(classFrame, text="--------------", bg="#323232", fg="#ffffff")
		dividingLabel.grid(sticky=W, row=row, column=2, padx=10)

		dividingLabel = Label(classFrame, text="---------", bg="#323232", fg="#ffffff")
		dividingLabel.grid(sticky=W, row=row, column=3)
		#------

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		row += 1

		#------
		#this is the addition section of the classframe, it will allow the user to add info to the settings.json file, as well as the actual page
		entryBoxClass = Entry(classFrame, bg="#ffffff", fg="#bebebe", width=10, highlightthickness=0, relief=FLAT)
		entryBoxClass.insert(0, "Class Name")
		entryBoxClass.grid(sticky=W, row=row, column=1, padx=10, pady=5)
		entryBoxClass.config(insertbackground="#000000")

		entryBoxOutcome = Entry(classFrame, bg="#ffffff", fg="#bebebe", width=11, highlightthickness=0, relief=FLAT)
		entryBoxOutcome.insert(0, "Class Outcomes")
		entryBoxOutcome.grid(sticky=W, row=row, column=2, padx=10, pady=5)
		entryBoxOutcome.config(insertbackground="#000000")

		addButton = Button(classFrame, text="add", command=lambda: self.addToEnv(settingsValues, entryBoxClass, entryBoxOutcome, cv, bodyFrame))
		addButton.grid(sticky=W, row=row, column=3, pady=5)
		#------

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		#this is another dividing frame that will separate the different operations in this page
		dividingLabel = Text(bodyFrame, bg="#323232", width=40, height=1, wrap=WORD, highlightthickness=0)
		dividingLabel.insert('1.0', "----------------------------------------")
		dividingLabel.config(state=DISABLED)
		dividingLabel.grid(sticky=W, row=4, column=0, padx=10)

		#this will tell the user what this section does
		subfolderLabel = Text(bodyFrame, bg="#323232", width=40, height=2, wrap=WORD, highlightthickness=0)
		subfolderLabel.insert('1.0', "--> Change the subfolders generated by the tool.")
		subfolderLabel.config(state=DISABLED)
		subfolderLabel.grid(sticky=W, row=5, column=0, padx=10, pady=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		#this frame will hold the values from the settings.json file
		subfolderFrame = Frame(bodyFrame, bg="#323232", width=330, height=50)
		subfolderFrame.grid(sticky=W, row=6, column=0)

		#--------
		#these are the columns in this frame, added to the subfolderFrame, NOT the bodyframe
		mainFolderLabel = Label(subfolderFrame, bg="#323232", fg="#ffffff", text="Main Folder")
		mainFolderLabel.grid(sticky=W, row=1, column=1, padx=2, pady=5)

		subfolderLabel = Label(subfolderFrame, bg="#323232", fg="#ffffff", text="Subfolders")
		subfolderLabel.grid(sticky=W, row=1, column=2, padx=0, pady=5)

		opLabel = Label(subfolderFrame, bg="#323232", fg="#ffffff", text="Operation")
		opLabel.grid(sticky=W, row=1, column=3, pady=5, padx=0)
		#--------

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))


		row = 2
		for keys in settingsValues["Subfolders"].keys():
			mnLabel = Label(subfolderFrame, bg="#323232", fg="#ffffff", text="+ " + keys + " --> ", name="label" + keys)
			mnLabel.grid(sticky=W, row=row, column=1, padx=2, pady=5)

			opButton = Button(subfolderFrame, text="del", name="but"+keys, command=lambda name=keys: self.removeFromEnv(name, subfolderFrame, canvas, bodyFrame, "Subfolders"))
			opButton.grid(sticky=W, row=row, column=3, pady=0, padx=5)

			if len(settingsValues["Subfolders"][keys]) != 0:
				for sfFolder in settingsValues["Subfolders"][keys]:
					row += 1

					#this is the actual subfolder
					sbFolder = Label(subfolderFrame, bg="#323232", fg="#ffffff", text=sfFolder + " --> ", name="fl" + sfFolder)
					sbFolder.grid(sticky=W, row=row, column=2, padx=0, pady=5)

					opButton = Button(subfolderFrame, text="del", name="but"+sfFolder, command=lambda name=sfFolder: self.removeFromEnv(name, subfolderFrame, canvas, bodyFrame, "Subfolders"))
					opButton.grid(sticky=W, row=row, column=3, pady=0, padx=5)
			

			row += 1

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))

		dividingLabel = Label(subfolderFrame, text="----------", bg="#323232", fg="#ffffff", name="dividingLine1")
		dividingLabel.grid(sticky=W, row=row, column=1, padx=10)

		dividingLabel = Label(subfolderFrame, text="---------", bg="#323232", fg="#ffffff", name="dividingLine2")
		dividingLabel.grid(sticky=W, row=row, column=2, padx=10)

		dividingLabel = Label(subfolderFrame, text="---------", bg="#323232", fg="#ffffff", name="dividingLine3")
		dividingLabel.grid(sticky=W, row=row, column=3, padx=10)

		row+=1

		entryBoxMain = Entry(subfolderFrame, bg="#ffffff", fg="#bebebe", width=10, highlightthickness=0, relief=FLAT, name="addButtonSubEntry")
		entryBoxMain.insert(0, "Class Name")
		entryBoxMain.grid(sticky=W, row=row, column=1, padx=10, pady=5)
		entryBoxMain.config(insertbackground="#000000")

		entryBoxSub = Entry(subfolderFrame, bg="#ffffff", fg="#bebebe", width=10, highlightthickness=0, relief=FLAT, name="addButtonSubEntry2")
		entryBoxSub.insert(0, "Subfolder")
		entryBoxSub.grid(sticky=W, row=row, column=2, padx=0, pady=5)
		entryBoxSub.config(insertbackground="#000000")

		addButton = Button(subfolderFrame, text="add", name="addButtonSub", command=lambda: self.addToEnv(settingsValues, entryBoxFolder, None, canvas, bodyFrame, "addButtonSub", subfolderFrame))
		addButton.grid(sticky=W, row=row, column=3, pady=5, padx=10)

		#this will introduce what is going on with this section
		divider = Label(bodyFrame, font=("san-serif", 3))
		divider.grid(sticky=W, row=7, column=0, padx=5)

		canvas.update_idletasks()
		canvas.configure(scrollregion=bodyFrame.bbox("all"))


	#this needs to stay here, this will hold each function to create each frame, I just need to save them here as I create them
	#__functions = {0: EmailList, 1: CabinetCreate, 2: DownloadCabinet, 3: AuditCabinet, 4: ParseAudit,
	#5: ExitInterview, 6: ReadIndirect, 7: ParseIndirect}
	__functions = {0: EmailList, 1: CabinetCreate, 2: AuditCabinet, 3: ParseDirect, 4: ExitInterview, 5: ReadIndirect, 6: ParseIndirect, 7:Settings}

	def __init__(self, root, current):
		self.__root = root
		body = Frame(root)
		body.place(x=150, y=40, width=350, height=360)
		self.__frame = body

		terminal = LiveTerminal(body)
		self.__terminal = terminal

		self.setTerminal(terminal)

		#---------------------
		#This will initialize the current body frame to whatever
		#tool is chosen
		#---------------------
		styleFrame = Frame(body, bg="#323232", highlightbackground="white", highlightthickness=2)
		styleFrame.place(x=10, y=10, width=330, height=235)

		self.__styleFrame = styleFrame

		#---------------------
		#This will be the title of the tool being used
		#---------------------
		toolTitle = Label(body, text=self.__tags[current], fg="#ffffff", bg="#323232")
		toolTitle.place(x=15, y=0)

		self.__toolTitle = toolTitle

		self.__current = current

		self.__functions[current](self)

	def changeFrame(self, index):
		for children in self.__styleFrame.winfo_children():
			children.pack_forget()

		self.__current = index #this is the index of the current frame
		self.__toolTitle.config(text=self.__tags[index])
		self.__terminal.destroy()
		self.__terminal = LiveTerminal(self.__frame)

		self.terminalDestroy()

		self.setTerminal(self.__terminal)

		#erase some of the global variables
		self.__filenames = dict()
		self.__directory = dict()
		self.__checkBoxes = dict()

		self.__styleFrame.unbind("<Button-1>")

		#Run the new frame
		self.__functions[self.__current](self)


